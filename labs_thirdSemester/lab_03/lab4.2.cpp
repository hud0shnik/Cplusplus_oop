#include <iostream>
#include <vector>
using namespace std;

//Поиск максимального паросочетания с помощью алгоритма Куна
bool try_kuhn(int v, vector < vector < int > > & g, vector < int > & used, vector < int > & mt) {
  if (used[v]) return false; //если вершина использована (УЧАСТВУЕТ В ПАРОСОЧЕТАНИИ) или как минимум обработана, то возвращаем 0
  used[v] = true; //иначе мы осмотрели вершину
  for (int i = 0; i < g[v].size(); ++i) {
    int to = g[v][i]; //перебрать строку v и посмотреть, куда можно из вершины v попасть
    if (mt[to] == -1 || try_kuhn(mt[to], g, used, mt)) //вершина не присутствует в решении?
    { //второе условие осматривает другие решения, то есть кода ребро есть, но оно используется в другом паросочетании и это мешает найти максимальное
      mt[to] = v; //может не дать лучшего решения (максимального паросочетания), если использовать только условие 1 в if
      return true;
    } //имея какое-то кол-во пар, продолжать поиск в глубину
  }
  return false;
}

int main() {
  int n = 3;
  int k = 8; //на 1 больше максимального элемента в матрице g
  vector < vector < int >> g = {
    {3,4,5,6},
    {5},
    {5,6,7}
  };
  vector < int > mt; //вектор максимальных паросочетаний
  vector < int > used; //показывает, какие вершины уже участвуют в решении
  for (int i = 0; i < n; i++) used.push_back(0);
  mt.assign(k, -1);
  for (int v = 0; v < n; ++v) {
    used.assign(n, false);
    if (try_kuhn(v, g, used, mt)) {
      for (int i = 0; i < k; ++i)
        if (mt[i] != -1)
          //каждый раз, когда мы получаем новые увеличивающие решения, то есть строим цепь, которая содержит большее количество пар, мы выводим результат
          cout << mt[i] << " => " << i << ", ";
      cout << "\n";
    }
  }
}